package Villager

import AITask
import Array 
import Consumer
import LinkedList
import MyMath 
import public Gender
import public VillagerObj
import Resources
import TimerHelpers
import TimerUtils
import UnitHelpers
import UnitWrapper

/// Amount of seconds after an order a villager can decide what to do on his own
@configurable constant real villagerIdleTimeout = 2

/// Wrapper around user that controls state of villager (hungry, heat, sick) 
/// and his AI. 
public class Villager extends UnitWrapper implements FoodConsumer
    Gender gender 
    real nutrition = 1.0 // from 0 to 1 
    real heat = 1.0  // from 0 to 1
    real immunity = 1.0 // from 0 to 1

    real foodConsumeSpd = 0.1
    real heatConsumeSpd = 0.1
    real hungryDps = 2

    bool hasHungryBuff = false // debuff ability is added
    bool isIdle = true 
    timer idleTimer = CreateTimer() 
    bool orderMask = false 

    LinkedList<AITask<Villager>> tasks // Holds all known tasks for this unit
    AITask<Villager> currentTask = null 
    static timer aiTickTimer = CreateTimer()
    use StaticArray<Villager>

    private function selfInit(Gender pgender)
        gender = pgender
        let collectFood = new TaskCollectFood()
        tasks = new LinkedList<AITask<Villager>>()
        tasks.add(collectFood)
        FoodConsumerAdded.addArrayItem(this)
        addArrayItem(this)

    override function onDestroy()
        FoodConsumerRemoved.addArrayItem(this)
        arrayRemoveWithPatch() (Villager a) -> 
            return a == this
        destroy tasks
        idleTimer.release()

    /// Construct from already created unit 
    construct(unit pu, Gender pgender)
        super(pu)
        selfInit(pgender)

    /// Create unit for player at given location and angle and init villager 
    /// from it.
    construct(player p, vec2 loc, angle a, Gender pgender)
        super(createUnit(p, villagerObjectId(pgender), loc, a))
        selfInit(pgender)

    /// Setting nutrition with guarding that value is in range [0, 1]
    function setNutrition(real nutrition) 
        this.nutrition = clamp(0, 1, nutrition)
    
    // Returns current nutrition of villager in range of [0, 1]
    function getNutrition() returns real 
        return nutrition 

    /// From FoodConsumer
    function foodPerSecond() returns food 
        return food(1)
    
    /// From FoodConsumer
    function foodConsumed(food consumed, real dt) 
        let required = foodPerSecond().value * dt 

        if consumed.value > 0.0 
            if nutrition < 1.0 
                let nutritionChange = foodConsumeSpd * consumed.value / required
                setNutrition(nutrition + nutritionChange)
                if hasHungryBuff
                    UnitRemoveAbility(u, hungryBuff.abilId)
                    hasHungryBuff = false
        else 
            if nutrition > 0.0 
                let nutritionChange = foodConsumeSpd
                setNutrition(nutrition - nutritionChange)
            else if not hasHungryBuff
                UnitAddAbility(u, hungryBuff.abilId)
                hasHungryBuff = true
            else
                u.damage(hungryDps * dt)
    
    /// From FoodConsumer
    function foodConsumeCategory() returns ConsumeCategory
        return ConsumeCategory.PEACEFULL_POPULATION

    /// From FoodConsumer
    function foodConsumerOwner() returns player 
        return GetOwningPlayer(u)

    /// Perform task calculations for all known villagers 
    static function tickAIAll()
        for i=0 to arrayLength()-1
            getArrayItem(i).tickAI()
    
    /// Perform task calculation for current village 
    function tickAI()
        if isIdle 
            let nextTask = selectTask()
            if currentTask == null 
                currentTask = nextTask
                currentTask.startTask(this)
            else if currentTask.taskPriority() < nextTask.taskPriority() or currentTask.isFinished()  
                currentTask.endTask(this)
                currentTask = nextTask 
                currentTask.startTask(this)

    /// Drop current order and mark the villager idle if the input flag is true
    function dropCurrentTask(bool markIdle)
        idleTimer.pause()
        isIdle = markIdle
        if currentTask != null 
            currentTask.endTask(this)
            currentTask = null 
        if not isIdle
            idleTimer.setData(this castTo int)
            idleTimer.start(villagerIdleTimeout) -> 
                let v = GetExpiredTimer().getData() castTo Villager
                v.isIdle = true 
    
    /// Find next most important task that we can perform
    private function selectTask() returns AITask<Villager> 
        AITask<Villager> result = null 
        for AITask<Villager> task in tasks
            if task.canPerformTask(this) 
                if result == null or result.taskPriority() < task.taskPriority()
                    result = task 
        return result 
    
    /// Internal function, called when any villager is given a order.  
    /// Must be a body of a trigger to work properly. 
    static function someoneGetOrder()
        let u = GetTriggerUnit()
        let uw = Villager.getInstanceThatBelongsTo(u)
        if uw != null 
            let v = uw castTo Villager 
            if v != null  
                if not v.orderMask 
                    v.dropCurrentTask(false)
                v.orderMask = false 
    
    /// Helper to issue point order with optional masking idle flag setting
    /// If taskMask set to 'true' the order won't drop current task.
    function issuePointOrder(string order, vec2 loc, bool taskMask) returns bool
        if taskMask 
            orderMask = true 
        return u.issuePointOrder(order, loc)

    /// Helper to issue target order with optional masking idle flag setting
    /// If taskMask set to 'true' the order won't drop current task.
    function issueTargetOrder(string order, widget target, bool taskMask) returns bool
        if taskMask 
            orderMask = true 
        return u.issueTargetOrder(order, target)

    /// Helper to issue immediate order with optional masking idle flag setting
    /// If taskMask set to 'true' the order won't drop current task.
    function issueImmediateOrder(string order, bool taskMask) returns bool
        if taskMask 
            orderMask = true 
        return u.issueImmediateOrder(order)

/// Global trigger that whatches after orders to villagers from user
trigger villagerOrderTrigger = CreateTrigger()

init 
    Villager.aiTickTimer.startPeriodic(3) -> 
        Villager.tickAIAll()
    TriggerRegisterAnyUnitEventBJ(villagerOrderTrigger, EVENT_PLAYER_UNIT_ISSUED_POINT_ORDER)  
    TriggerRegisterAnyUnitEventBJ(villagerOrderTrigger, EVENT_PLAYER_UNIT_ISSUED_TARGET_ORDER)  
    TriggerRegisterAnyUnitEventBJ(villagerOrderTrigger, EVENT_PLAYER_UNIT_ISSUED_ORDER)  
    TriggerAddAction(villagerOrderTrigger) -> 
        Villager.someoneGetOrder() 
     
/// Task that each villager do if not busy with another tasks
class TaskCollectFood implements AITask<Villager>
    use EmbeddedTimerPeriodic
    Villager v 

    /// Least important 
    function taskPriority() returns int 
        return 0
    
    /// Any villager can perform the task
    function canPerformTask(Villager _v) returns bool 
        return true 
    
    /// Start collecting food 
    function startTask(Villager pv)
        v = pv 
        start(5)
        UnitAddAbility(pv.getUnit(), collectingBuff.abilId)

    /// Stop collecting food 
    function endTask(Villager pv)
        v = null 
        stop()
        UnitRemoveAbility(pv.getUnit(), collectingBuff.abilId)
    
    override function callTimer(thistype t)
        let v = t.v
        let u = v.getUnit()
        let pos = u.getPos()
        let dx = GetRandomReal(-300, 300)
        let dy = GetRandomReal(-300, 300)
        let newPos = pos + vec2(dx, dy)
        v.issuePointOrder("move", newPos, true)

    /// This task is endless
    function isFinished() returns bool 
        return false 
