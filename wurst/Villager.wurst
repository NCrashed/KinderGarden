package Villager

import AITask
import Consumer
import public Gender
import public VillagerObj
import UnitWrapper
import Resources
import MyMath 
import UnitHelpers
import TimerHelpers
import LinkedList
import Array 

/// Wrapper around user that controls state of villager (hungry, heat, sick) 
/// and his AI. 
public class Villager extends UnitWrapper implements FoodConsumer
    Gender gender 
    real nutrition = 1.0 // from 0 to 1 
    real heat = 1.0  // from 0 to 1
    real immunity = 1.0 // from 0 to 1

    real foodConsumeSpd = 0.1
    real heatConsumeSpd = 0.1
    real hungryDps = 2

    bool hasHungryBuff = false // debuff ability is added

    LinkedList<AITask<Villager>> tasks // Holds all known tasks for this unit
    AITask<Villager> currentTask = null 
    static timer aiTickTimer = CreateTimer()
    use StaticArray<Villager>

    private function selfInit(Gender pgender)
        gender = pgender
        let collectFood = new TaskCollectFood()
        tasks = new LinkedList<AITask<Villager>>()
        tasks.add(collectFood)
        FoodConsumerAdded.addArrayItem(this)
        addArrayItem(this)

    override function onDestroy()
        FoodConsumerRemoved.addArrayItem(this)
        arrayRemoveWithPatch() (Villager a) -> 
            return a == this
        destroy tasks

    /// Construct from already created unit 
    construct(unit pu, Gender pgender)
        super(pu)
        selfInit(pgender)

    /// Create unit for player at given location and angle and init villager 
    /// from it.
    construct(player p, vec2 loc, angle a, Gender pgender)
        super(createUnit(p, villagerObjectId(pgender), loc, a))
        selfInit(pgender)

    /// Setting nutrition with guarding that value is in range [0, 1]
    function setNutrition(real nutrition) 
        this.nutrition = clamp(0, 1, nutrition)
    
    // Returns current nutrition of villager in range of [0, 1]
    function getNutrition() returns real 
        return nutrition 

    /// From FoodConsumer
    function foodPerSecond() returns food 
        return food(1)
    
    /// From FoodConsumer
    function foodConsumed(food consumed, real dt) 
        let required = foodPerSecond().value * dt 

        if consumed.value > 0.0 
            if nutrition < 1.0 
                let nutritionChange = foodConsumeSpd * consumed.value / required
                setNutrition(nutrition + nutritionChange)
                if hasHungryBuff
                    UnitRemoveAbility(u, hungryBuff.abilId)
                    hasHungryBuff = false
        else 
            if nutrition > 0.0 
                let nutritionChange = foodConsumeSpd
                setNutrition(nutrition - nutritionChange)
            else if not hasHungryBuff
                UnitAddAbility(u, hungryBuff.abilId)
                hasHungryBuff = true
            else
                u.damage(hungryDps * dt)
    
    /// From FoodConsumer
    function foodConsumeCategory() returns ConsumeCategory
        return ConsumeCategory.PEACEFULL_POPULATION

    /// From FoodConsumer
    function foodConsumerOwner() returns player 
        return GetOwningPlayer(u)

    /// Perform task calculations for all known villagers 
    static function tickAIAll()
        for i=0 to arrayLength()-1
            getArrayItem(i).tickAI()
    
    /// Perform task calculation for current village 
    function tickAI()
        
init 
    Villager.aiTickTimer.startPeriodic(3) -> 
        Villager.tickAIAll()
        
/// Task that each villager do if not busy with another tasks
class TaskCollectFood implements AITask<Villager>
    use EmbeddedTimerPeriodic
    Villager v 

    /// Least important 
    function taskPriority() returns int 
        return 0
    
    /// Any villager can perform the task
    function canPerformTask(Villager _v) returns bool 
        return true 
    
    /// Start collecting food 
    function startTask(Villager pv)
        v = pv 
        start(2)

    /// Stop collecting food 
    function endTask(Villager _pv)
        v = null 
        stop()
    
    override function callTimer(thistype t)
        let u = t.v.getUnit()
        let pos = u.getPos()
        let dx = GetRandomReal(-100, 100)
        let dy = GetRandomReal(-100, 100)
        let newPos = pos + vec2(dx, dy)
        u.issuePointOrder("move", newPos)